#!/usr/bin/env python

"""
NAME: multi_variable_pcoa_plot.py
DESCRIPTION: multi_variable_pcoa_plot.py is a python script to perform principal coordinate analysis based on
             taxanomic abundance or functional abundances with the possibility of analyzing three parameters together.
             Of note, multi_variable_pcoa_plot can be used as module too.
DATE: 31.10.2023
Author: Kun D. Huang
"""

from skbio.diversity import beta_diversity
from skbio.stats.ordination import pcoa
from skbio.stats.distance import DistanceMatrix
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
import seaborn as sns
import sys
import argparse
import math
from skbio.stats.distance import anosim
import textwrap
from collections import namedtuple

def read_args(args):
    # This function is to parse arguments

    parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter,
                                    description = textwrap.dedent('''\
                                     This program is to do PCoA analysis on microbial taxonomic or functional abundance data integrating maximum three variables together.
                                     '''),
                                    epilog = textwrap.dedent('''\
                                    examples:
                                    pcoa_painter.py --abundance_table <merged_metaphlan_table> --metadata <metadata> --sample_column <sample_header> --variable1 <variable1_name> --variable2 <variable2_name> --variable3 <variable3_name> --output_figure <output.png>
                                    '''))

    parser.add_argument('--abundance_table',
                        nargs = '?',
                        help = 'Input the merged abundance table generated by MetaPhlAn.',
                        type = str,
                        default = None)

    parser.add_argument('--metadata',
                        nargs = '?',
                        help = 'Input a tab-delimited metadata file.',
                        type = str,
                        default = None)

    parser.add_argument('--transformation',
                        nargs = '?',
                        help = 'Specify the tranformation function applied on data points in the original table. \
                                For abundance table, you can choose <sqrt>/<log>. \
                                Default setting is <None>.',
                        type = str,
                        default = None)

    parser.add_argument('--metric',
                        nargs = '?',
                        help = 'Specify the metric you want to use for calculating beta diversity in the case of as input using \
                                abundance table.<braycurtis>/<unweighted_unifrac>/<jaccard>/<weighted_unifrac>. \
                                Default setting is <braycurtis>',
                        type = str,
                        default = 'braycurtis')

    parser.add_argument('--amplifier',
                        nargs = '?',
                        help = 'Specify how much you want to amplify your original data point. For example, \
                        <--amplifier 100> indicates that all original data point times 100. Default is 1.',
                        type = int,
                        default = 1)

    parser.add_argument('--sample_column',
                        nargs = '?',
                        help = 'Specify the header of column containing metagenome sample names in the metadata file.',
                        type = str,
                        default = None)

    parser.add_argument('--variable1',
                        nargs = '?',
                        help = 'Specify the header of the variable in the metadata table you want to assess. This variable will be represented by colors.',
                        type = str,
                        default = None)

    parser.add_argument('--variable2',
                        nargs = '?',
                        help = 'Specify the header of second variable in the metadata table you want to assess. This variable will be represented by marker shapes.',
                        type = str,
                        default = None)

    parser.add_argument('--variable3',
                        nargs = '?',
                        help = 'Specify the header of the third variable in the metadata table you want to assess. This variable will be represented by marker sizes.',
                        type = str,
                        default = None)

    parser.add_argument('--marker_palette',
                        nargs = '?',
                        help = 'Input a tab-delimited mapping file where 1st column contains group names and 2nd column contains color codes. default: [None] (automatic handling)',
                        type = str,
                        default = None)
    
    parser.add_argument('--marker_shapes',
                        nargs = '?',
                        help = 'Input a tab-delimited mapping file where 1st column contains group names and 2nd column contains marker shapes. default: [None] (automatic handling)',
                        type = str,
                        default = None)

    parser.add_argument('--marker_sizes',
                        nargs = '?',
                        help = 'Input a tab-delimited mapping file where values are group names and keys are marker size. default: [None] (automatic handling)',
                        type = str,
                        default = None)
    
    parser.add_argument('--output_figure',
                        nargs = '?',
                        help = 'Specify the name for the output figure. For example, output_figure.svg',
                        type = str,
                        default = None)

    parser.add_argument('--test',
                        nargs = '?',
                        help = 'Specify an output file for saving permanova test results. For example, project_name_stats.tsv',
                        type = str,
                        default = None)


    parser.add_argument('--df_opt',
                        nargs = '?',
                        help = 'Specify the output name for saving coordinates (PC1 and PC2) for each sample. For example, project_name_coordinates.tsv',
                        type = str,
                        default = None)

    parser.add_argument('--font_style',
                        nargs = '?',
                        help = 'Specify the font style which is composed by font family and font type, delimited with a comma. default: [sans-serif,Arial]',
                        type = str,
                        default = "sans-serif,Arial")
    
    parser.add_argument('--font_size',
                        nargs = '?',
                        help = 'Specify the font size. default: [11]',
                        type = int,
                        default = 11)

    return vars(parser.parse_args())

class BetaDiversity:

    """
    This object is to deal with beta diversity analysis
    """

    def __init__(self, matrix_value, metadata):
        # matrix_value: the merged standard relative abundance table from metaphlan.
        # metadata: the tab-delimited metadata file, each column contains one metadata parameter.

        self.abundance_table = matrix_value
        self.metadata = metadata

    def est_beta_diversity_matrix(self, trans_func, diversity_metric, amplifier):
        # trans_func: the function for transforming abundance values, e.g. sqrt or log.
        # diversity_metric: the metric for calculating beta diversity, e.g. jaccard or braycurtis.
        # amplifier: N times the relative abundnce values, e.g. 10000
        # this function is to estimate beta diversity by users' defined transformation function and metric.

        raw_df = pd.read_csv(self.abundance_table, sep = "\t", index_col = False) # read merged metaphlan table into a dataframe
        df = raw_df.loc[(raw_df.sum(axis=1) != 0), (raw_df.sum(axis=0) != 0)] # clean raw df by removing zero-sum rows and columns
        ids = df.columns[1:] # get all sample names
        matrix = [] # the matrix of rel abundance, each row contains all abundances for one sample
        for s in ids:
            bug_abundances_one_sample = []
            for i in df.index:
                abundance_value = df.loc[i, s]
                if trans_func == None:
                    bug_abundances_one_sample.append(float(abundance_value) * amplifier)
                elif trans_func == 'sqrt':
                    bug_abundances_one_sample.append(math.sqrt(float(abundance_value) * amplifier)) 
                elif trans_func == 'log':
                    bug_abundances_one_sample.append(math.log1p(float(abundance_value) * amplifier + 1)) 
                else:
                    sys.exit("Please choose transformation function from <sqrt>/<log>/<None>")
            matrix.append(bug_abundances_one_sample)

        return beta_diversity(diversity_metric, matrix, ids)
    def get_valid_samples(self):
        # this function is to return a list of valid samples to match with metadata.
        raw_df = pd.read_csv(self.abundance_table, sep = "\t", index_col = False)
        df = raw_df.loc[(raw_df.sum(axis=1) != 0), (raw_df.sum(axis=0) != 0)]

        return df.columns

    def get_valid_metadata(self, index_col, variables):
        # index_col: the column name for index column.
        # variable: the variable parameter one wants to map on the PCoA plot.
        variables = [i for i in variables if i]
        variables = list(set(variables))
        if len(variables) > 0:
            metadata_df = pd.read_csv(self.metadata, sep = "\t", index_col = index_col)[variables]
            valid_samples = self.get_valid_samples() # get all samples which match with those in the metadata table.
            metadata_index = metadata_df.index
            rows_to_drop = [i for i in metadata_index if i not in valid_samples]
            metadata_df = metadata_df.drop(rows_to_drop) # drop those rows in the metadata table where samples cannot be found in the abundance table
            return metadata_df
        else:
            sys.exit("None of three variables were detected. Please specify at least one variable using --variable1, --variable2 or --variable3!")

    def pcoa_df(self, data_matrix, index_col, variables):
        # data_matrix: the skbio style matrix fed into PCoA analysis.
        # index_col: the column name for index column.
        # variable: the variable parameter one wants to map on the PCoA plot.
        # this function is to perform pcoa analysis on the skbio-style matrix.
        variables = [i for i in variables if i ]
        variables = list(set(variables))
        if len(variables) > 0:
            PCoAs= pcoa(data_matrix)
            coordinates= PCoAs.samples.loc[:, ["PC1", "PC2"]] # Take first two coordinates
            PC_explained = PCoAs.proportion_explained
            PC1_p = round(PC_explained['PC1']*100,2) #PC1 explained percentage
            PC2_p = round(PC_explained['PC2']*100,2) #PC2 explained percentage
            metadata_df = self.get_valid_metadata(index_col, variables)
            return pd.concat([coordinates, metadata_df], axis = 1), PC1_p, PC2_p
        else:
            sys.exit("None of three variables were detected. Please specify at least one variable using --variable1, --variable2 or --variable3!")
            

    def permanova_test(self, data_matrix, index_col, variable):
        # data_matrix: the skbio style matrix fed into PCoA analysis.
        # this function is to perform permanova test.
        # Note: this test is a bit inconsistent with R package, be careful.

        permanova_results = namedtuple('permanova_results', ['statistic', 'pvalue'])

        metadata_df = self.get_valid_metadata(index_col, [variable])

        anosim_test = anosim(data_matrix, metadata_df, column= variable, permutations = 999)


        return permanova_results(anosim_test['test statistic'], anosim_test["p-value"])

    def pcoa_plotting(self, data_matrix, opt_figure, index_col, df_opt, 
                      variable1 = None, variable2 = None, variable3 = None, 
                      marker_sizes = None, marker_palette = None, marker_shapes = None,
                      font_style = "sans-serif,Arial", font_size = 11):
        # this function is to plot the PCoA analysis results
        # palette: a mapping file in which 1st column is group name and 2nd column is color code. No header row!
        font_family, font_type = font_style.split(",")
        fig, ax = plt.subplots()
        matplotlib.rcParams['font.family'] = font_family 
        matplotlib.rcParams['font.{}'.format(font_family)] = font_type
        variables = [variable1, variable2, variable3]
        pcoa_coords, PC1_p, PC2_p = self.pcoa_df(data_matrix, index_col, variables)
        if marker_palette:
            palette_dict = {i.rstrip().split('\t')[0]: i.rstrip().split('\t')[1] for i in open(marker_palette).readlines()}
        else:
            palette_dict = None

        if marker_shapes:
            shape_dict = {i.rstrip().split('\t')[0]: i.rstrip().split('\t')[1] for i in open(marker_shapes).readlines()}
        else:
            shape_dict = True        

        if marker_sizes:
            sizes_dict = {i.rstrip().split('\t')[0]: float(i.rstrip().split('\t')[1]) for i in open(marker_sizes).readlines()}
        else:
            sizes_dict = None
        
        if df_opt:
            pcoa_coords.to_csv(df_opt, sep = "\t", index = False)
            
        
        sns.scatterplot(x = "PC1", y = "PC2", data = pcoa_coords,
                        hue = variable1, palette = palette_dict,
                        style = variable2,
                        markers = shape_dict, 
                        size = variable3, sizes = sizes_dict,
                        ax = ax)
        
        ax.set_xlabel('PC1({}%)'.format(str(PC1_p)), fontsize = font_size)
        ax.tick_params(axis = "x", labelsize = font_size) 
        ax.set_ylabel('PC2({}%)'.format(str(PC2_p)), fontsize = font_size)
        ax.tick_params(axis = "y", labelsize = font_size) 
        ax.legend(bbox_to_anchor=(1.01, 1), loc=2,borderaxespad=0.)
        fig.savefig(opt_figure, bbox_inches = 'tight', dpi = 600)

if __name__ == '__main__':
    pars = read_args(sys.argv)
    if pars['metadata']:
        if pars['sample_column']:
            variables = list(set([pars['variable1'], pars['variable2'], pars['variable3']]))
            variables = [i for i in variables if i]
            if len(variables) > 0:
                b_diversity_analysis = BetaDiversity(pars['abundance_table'], pars['metadata'])
                b_diversity_matrix = b_diversity_analysis.est_beta_diversity_matrix(pars['transformation'],
                                                                                    pars['metric'],
                                                                                    pars['amplifier'])
                b_diversity_analysis.pcoa_plotting(b_diversity_matrix,
                                                   pars['output_figure'],
                                                   pars['sample_column'],
                                                   pars['df_opt'],
                                                   variable1 = pars['variable1'],
                                                   variable2 = pars['variable2'],
                                                   variable3 = pars['variable3'],
                                                   marker_sizes = pars['marker_sizes'],
                                                   marker_palette = pars['marker_palette'],
                                                   marker_shapes = pars['marker_shapes'],
                                                   font_style = pars['font_style'],
                                                   font_size = pars['font_size']
                                                   )
                if pars['test']:
                    results_matrix = []
                    for single_variable in variables:
                        permanova_opt = b_diversity_analysis.permanova_test(b_diversity_matrix,
                                                                             pars['sample_column'],
                                                                             single_variable)
                        
                        results_matrix.append([single_variable, permanova_opt.statistic, permanova_opt.pvalue])
                    stats_df = pd.DataFrame(results_matrix, columns = ['factor', 'statistic', 'p-value'])
                    stats_df.to_csv(pars['test'], sep = '\t', index = False)       
            else:
                sys.exit("None of three variables were detected. Please specify at least one variable using --variable1, --variable2 or --variable3!")
        else:
            sys.exit('Please specify the column name containing samples!')
    else:
        sys.exit('Please input a proper metadata file!')
